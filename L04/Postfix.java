import java.util.Stack;import static java.lang.Integer.valueOf;/** * A class that represents a postfix expression. * * @author Sean Blanchard * @version 02/12/2019 */public class Postfix{    /**     * Creates a postfix expression that represents a given infix expression.     * Segment 5.16     *     * @param infix a string that is a valid infix expression     * @return a string that is the postfix expression equivalent to infix     */    public void convertToPostfix(String infix)    {        // TODO PROJECT #4        System.out.println("Infix:   " + infix);        Stack<Character> operatorStack = new Stack<>();        StringBuilder postfix = new StringBuilder();        int characterCount = infix.length();        // IMPLEMENT ALGORITHM 5.16//        for(int i = 0; i < characterCount; i++)//        {//            char topSign = infix.charAt(i);//            if(topSign != ' ')//            {//                if(Character.isLetterOrDigit(topSign))//                {//                    postfix.append((topSign));//                }//                else if( topSign == '(')//                {//                    operatorStack.push(topSign);//                }//                else if( topSign == ')')//                {//                    while(!operatorStack.isEmpty() && operatorStack.peek() != '(')//                    {//                        postfix.append((operatorStack.pop()));//                    }//                } else//                {//                    operatorStack.pop();//                }////                while(!operatorStack.isEmpty() && getPrecedence(topSign) <= getPrecedence(operatorStack.peek()))//                {//                    postfix.append(operatorStack.pop());//                    operatorStack.push(topSign);//                }//            }//        }        // utilize Character.isLetter method        // utilize getPrecedence method//        while (!operatorStack.isEmpty())//        {//            postfix.append(operatorStack.pop());//            System.out.println("Postfix: " + postfix.toString());//            System.out.println("\n");//        }        for (int i = 0; i < characterCount; ++i) {            char topSign = infix.charAt(i);            if (topSign != ' ') {                if (Character.isLetterOrDigit(topSign))                {                    postfix.append(topSign);                }                else if (topSign == '(')                {                    operatorStack.push(topSign);                }                else if (topSign == ')') {                    while (!operatorStack.isEmpty() && operatorStack.peek() != '(')                    {                        postfix.append(operatorStack.pop());                    }                    if (!operatorStack.isEmpty() && operatorStack.peek() != '(')                    {                        System.out.println("Expression is invalid");                    }                    else {                        operatorStack.pop(); //Find the start                    }                }                else                    {                    while (!operatorStack.isEmpty()                            && getPrecedence(topSign) <= getPrecedence(operatorStack.peek()))                        postfix.append(operatorStack.pop());                    operatorStack.push(topSign);                }            }        }        while (!operatorStack.isEmpty())            postfix.append(operatorStack.pop());        System.out.println("Postfix: " + postfix.toString());        System.out.println("\n");//        System.out.println("Postfix: " + postfix.toString());////        System.out.println("\n");    } // end convertToPostfix    /**     * Indicates the precedence of a given operator.     *     * @param operator a character that is (, ), +, -, *, /, or ^     * @return an integer that indicates the precedence of operator:     *         0 if ( or ), 1 if + or -, 2 if * or /, 3 if ^, -1 if     *         anything else     */    private int getPrecedence(char operator)    {        switch (operator)        {            case '(':            case ')':                return 0;            case '+':            case '-':                return 1;            case '*':            case '/':                return 2;            case '^':                return 3;        } // end switch        return -1;    } // end getPrecedence    /**     * Evaluates a postfix expression.     * Segment 5.18     *     * @param postfix a string that is a valid postfix expression     * @return the value of the postfix expression     */    public double evaluatePostfix(String postfix)    {        // TODO PROJECT #4        Stack<Double> valueStack = new Stack<>();        int characterCount = postfix.length();        // IMPLEMENT ALGORITHM 5.18        // utilize Character.isLetter method        // utilize compute and valueOf methods        for (int i = 0; i < characterCount; i++) {            char c = postfix.charAt(i);            if (c != ' ') {                if (Character.isAlphabetic(c)) {                    double d = valueOf(c);                    valueStack.push(d);                } else {                    double sign1 = valueStack.pop();                    double sign2 = valueStack.pop();                                        switch (c) {                        case '+':                            valueStack.push(compute(sign1, sign2, '+'));                            break;                        case '-':                            valueStack.push(compute(sign2, sign1, '-'));                            break;                        case '/':                            valueStack.push(compute(sign2, sign1, '/'));                            break;                        case '^':                            valueStack.push(compute(sign2, sign1, '^'));                            break;                        case '*':                            valueStack.push(compute(sign2, sign1, '*'));                            break;                    }                }            }        }        return valueStack.pop(); // THIS IS A STUB    } // end evaluatePostfix    private double valueOf(char variable)    {        switch (variable)        {            case 'a':                return 2.0;            case 'b':                return 3.0;            case 'c':                return 4.0;            case 'd':                return 5.0;            case 'e':                return 6.0;        } // end switch        return 0;    } // end valueOf    private double compute(double operandOne, double operandTwo, char operator)    {        double result = 0;        switch (operator)        {            case '+':                result = operandOne + operandTwo;                break;            case '-':                result = operandOne - operandTwo;                break;            case '*':                result = operandOne * operandTwo;                break;            case '/':                if (operandTwo != 0)                    result = operandOne / operandTwo;                break;            case '^':                result = Math.pow(operandOne, operandTwo);                break;        } // end switch        return result;    } // end compute    public static void main(String[] args)    {        Postfix tester = new Postfix();        System.out.println("Converting infix expressions to postfix expressions:\n");        tester.convertToPostfix("a+b");        tester.convertToPostfix("(a + b) * c");        tester.convertToPostfix("a * b / (c - d)");        tester.convertToPostfix("a / b + (c - d)");        tester.convertToPostfix("a / b + c - d");        tester.convertToPostfix("a^b^c");        tester.convertToPostfix("(a^b)^c");        tester.convertToPostfix("a*(b/c+d)");        tester.convertToPostfix("(a+b)/(c-d)");        tester.convertToPostfix("a/(b-c)*d");        tester.convertToPostfix("a-(b/(c-d)*e+f)^g");        tester.convertToPostfix("(a-b*c)/(d*e^f*g+h)");        System.out.println("Evaluating postfix expressions with\n" +                "a = 2, b = 3, c = 4, d = 5, e = 6");        System.out.println("Assuming correct input!!!\n\n");        System.out.println("ae+bd-/ : " + tester.evaluatePostfix("ae+bd-/") + "\n");        System.out.println("abc*d*- : " + tester.evaluatePostfix("abc*d*-") + "\n");        System.out.println("abc-/d* : " + tester.evaluatePostfix("abc-/d*") + "\n");        System.out.println("ebca^*+d- : " + tester.evaluatePostfix("ebca^*+d-") + "\n");        System.out.println("Done.");    }  // end main} // end Postfix                 