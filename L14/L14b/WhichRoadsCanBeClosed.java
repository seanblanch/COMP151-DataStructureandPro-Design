package Lab14b;import javax.swing.text.Element;import java.util.*;import java.util.concurrent.LinkedBlockingQueue;/** * A class that creates a minimum spanning tree * for a given graph * The graph is represented by adjacency matrix * * @author atb * @version 4/30/2019 */public class WhichRoadsCanBeClosed{    // The matrix below represents the graph from the example provided in the lab description    // The instructor used this hardcoded matrix for testing,    // your code however must generate the matrix randomly//    private int[][] adjMatrix = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},//            {0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 2},//            {0, 0, 0, 4, 0, 0, 10, 0, 0, 0, 0},//            {0, 3, 4, 0, 3, 5, 0, 0, 0, 0, 0},//            {0, 1, 0, 3, 0, 2, 0, 0, 0, 0, 0},//            {0, 0, 0, 5, 2, 0, 6, 0, 1, 0, 0},//            {0, 0, 10, 0, 0, 6, 0, 9, 10, 0, 0},//            {0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0},//            {0, 0, 0, 0, 0, 1, 10, 0, 0, 8, 0},//            {0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 10},//            {0, 2, 0, 0, 0, 0, 0, 0, 0, 10, 0}};    private int[][] adjMatrix;    private int[][] minimumSpanningTree;    private int numberOfNodes;    final int GRAYED_OUT = -1;    final int UNMARK_FOR_CHECKING = 0;    final int PERCENT100 = 100;    final int MAX_WEIGHT = 25;    public WhichRoadsCanBeClosed(int numberOfNodes, int probability)    {        //TODO Lab14b #1.1        this.numberOfNodes = numberOfNodes;        this.adjMatrix = new int[numberOfNodes + 1][this.numberOfNodes + 1];       this.minimumSpanningTree = new int [this.numberOfNodes + 1][this.numberOfNodes + 1];        Random rand = new Random(101);        for(int row = 1; row < this.numberOfNodes; row++)        {            for(int column = 1+1; column < this.numberOfNodes+1; column++)            {                int newRandom = rand.nextInt(this.PERCENT100);                if(newRandom <= probability)                {                    int weight = rand.nextInt(this.numberOfNodes) + 1;                    this.adjMatrix[row][column] = weight;                    this.adjMatrix[column][row] = weight;                }            }        }    }    public void displayRoadsThatCanBeClosed()    {        System.out.println("\nThe following roads can be closed:");        //TODO Lab14b #1.4        for(int i = 0; i < adjMatrix.length; i++)        {        }        if(minimumSpanningTree == adjMatrix)        {            displayRoadsThatCanBeClosed();        }    }    public boolean isConnected()    {        //TODO Lab14b #1.5        // utilize breath-first-traversal algorithm        for(int i = 0; i < this.numberOfNodes + 1; i++)        {            this.adjMatrix[i][0] = 0;            this.adjMatrix[0][i] = 0;        }        Integer counter = 0;        Queue<Integer> vertexQueue =                new LinkedBlockingQueue<Integer>();        int originVertex = 1;        this.adjMatrix[0][1] = this.GRAYED_OUT;        counter++;    // enqueue vertex label        vertexQueue.offer(originVertex); // enqueue vertex        while (!vertexQueue.isEmpty())        {            Integer frontVertex = vertexQueue.poll();            for (int i = 1; i < this.numberOfNodes +1 ; i++) {                if(this.adjMatrix[frontVertex][i] !=0 && this.adjMatrix[0][i] != this.GRAYED_OUT){                    this.adjMatrix[0][i] = this.GRAYED_OUT;                    counter++;                    vertexQueue.offer(i);                }            }        }        // utilize BFS algorithm        return this.numberOfNodes == counter;    }    public boolean minimumSpanningTreeCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.minimumSpanningTree, 1, visited);    }    public boolean connectedGraphCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.adjMatrix, 1, visited);    }    private boolean hasCycle(int[][] graphToCheck, int start, boolean[] visited)    {        //TODO Lab14b #1.6        visited[start] = true;        for (int j = start + 1; j <= this.numberOfNodes; j++) {             //if start and j are connected return true if either j was visited or recursive call starting with j returns true            if(graphToCheck[start][j] != 0 || hasCycle(graphToCheck, j, visited))            {                return true;            }        }        return false;    }    public void calculateMinimumSpanningTree()    {        //TODO Lab14b #1.3        // utilize findSmallestInMarkedRows method        for(int i = 0; i < this.numberOfNodes+1; i++)        {            this.adjMatrix[i][0] = 0;            this.adjMatrix[0][i] = 0;        }        this.adjMatrix[1][0] = this.UNMARK_FOR_CHECKING;        this.adjMatrix[0][1] = this.GRAYED_OUT;        for(int i = 0; i < this.numberOfNodes; i++)        {            SmallestWithIndexes smallest = findSmallestInMarkedRows();            this.minimumSpanningTree[smallest.column][smallest.row] = smallest.value;            this.minimumSpanningTree[smallest.row][smallest.column] = smallest.value;            this.adjMatrix[smallest.column][0] = this.UNMARK_FOR_CHECKING;            this.adjMatrix[0][smallest.column] = this.GRAYED_OUT;        }    }    private SmallestWithIndexes findSmallestInMarkedRows()    {        //TODO Lab14b #1.2        int smallest = this.MAX_WEIGHT;        int row = 0;        int col = 0;        for(int i = 1; i < this.numberOfNodes; i++)        {            if(this.adjMatrix[i][0] == 0)            {                for(int j = 1; j <= this.numberOfNodes; j++)                {                    if(this.adjMatrix[0][j] != this.GRAYED_OUT)                    {                        if(smallest > this.adjMatrix[i][j] && this.adjMatrix[i][j] != 0)                        {                            row = i;                            col = j;                            smallest = this.adjMatrix[i][j];                            System.out.println("row= " + row + "; col= " + col + "; smallest= " + smallest);                        }                    }                }            }        }        //System.out.println("row= " + row + "; col= " + col + "; smallest= " + smallest);        return new SmallestWithIndexes(row, col, smallest);    }    public void displayGraph()    {        System.out.println("***** GENERATED GRAPH *****");        displayMatrix(this.adjMatrix);    }    public void displayMinimumSpanningTree()    {        System.out.println("\n\n***** Computed MINIMUM SPANNING TREE for the above graph *****");        displayMatrix(this.minimumSpanningTree);    }    private void displayMatrix(int[][] matrix)    {        System.out.print("     ");        for (int c = 1; c <= this.numberOfNodes; c++)        {            System.out.printf("[%1$2d]", c);        }        System.out.println();        for (int r = 1; r <= this.numberOfNodes; r++)        {            System.out.printf("[%1$2d]", r);            for (int c = 1; c <= this.numberOfNodes; c++)            {                if (matrix[r][c] > 0)                    System.out.printf("%1$4d", matrix[r][c]);                else                    System.out.printf("%1$4s", " ");            }            System.out.println();        }    }    private void displayMSTinLevelOrder()    {        System.out.println("\n\n***** Computed MINIMUM SPANNING TREE in Level-order *****");        //TODO Lab14b #1.7    }    public static void main(String[] args)    {        System.out.println("How many nodes in your graph?");        Scanner scan = new Scanner(System.in);        int numberOfNodes = scan.nextInt();        System.out.println("Probability of edge? (type 70 for 70%)");        int probability = scan.nextInt();        WhichRoadsCanBeClosed graph = new WhichRoadsCanBeClosed(numberOfNodes, probability);        graph.displayGraph();        if (graph.isConnected())        {            if (graph.connectedGraphCheckForCycle())                System.out.println("\nThe graph has cycles.");            else                System.out.println("\nThe graph is acyclic.");            graph.calculateMinimumSpanningTree();            graph.displayMinimumSpanningTree();            graph.displayRoadsThatCanBeClosed();            if (graph.minimumSpanningTreeCheckForCycle())                System.out.println("\nThe minimum spanning tree has cycles.");            else                System.out.println("\nThe minimum spanning tree is acyclic.");            graph.displayMSTinLevelOrder();        }        else            System.out.println("The graph is not connected, the minimum spanning tree will not be calculated");    } // end main    private class SmallestWithIndexes    {        private int row;        private int column;        private int value;        public SmallestWithIndexes(int row, int column, int value)        {            this.row = row;            this.column = column;            this.value = value;        }    }}