package Lab12;import java.util.*;import java.util.NoSuchElementException;import java.io.Serializable;/** * A class that implements the ADT dictionary by using hashing and * linear probing to resolve collisions. * The dictionary is unsorted and has distinct search keys. *  Notes: Uses probe for add, but locate for remove and getValue. * Has a display method for illustration and testing. * * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.0 * * @modified by atb * * @author Sean Blanchard * @version 4/16/2019 */public class HashedDictionary<K,V> implements DictionaryInterface<K,V>,Serializable{    // The dictionary:    private int numberOfEntries;    private static final int DEFAULT_CAPACITY = 5;     // Must be prime    private static final int MAX_CAPACITY = 10000;    // The hash table:    private TableEntry<K, V>[] hashTable;    private static final int MAX_SIZE = 2 * MAX_CAPACITY;    private boolean initialized = false;    private static final double MAX_LOAD_FACTOR = 0.5; // Fraction of hash table that can be filled    private int probes;    public HashedDictionary()    {        this(DEFAULT_CAPACITY); // Call next constructor    } // end default constructor    public HashedDictionary(int initialCapacity)    {        initialCapacity = checkCapacity(initialCapacity);        this.numberOfEntries = 0;    // Dictionary is empty        // Set up hash table:        // Initial size of hash table is same as initialCapacity if it is prime;        // otherwise increase it until it is prime size        int tableSize = getNextPrime(initialCapacity);        checkSize(tableSize);        // The cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        TableEntry<K, V>[] temp = (TableEntry<K, V>[])new TableEntry[tableSize];        this.hashTable = temp;        this.initialized = true;        this.probes = 0;    } // end constructor    // We've added this method to display the hash table for illustration and testing    public void displayHashTable()    {        System.out.println("The size of hash table is: " + this.hashTable.length);        //System.out.println("In displayHashTable - implement me");            // TODO Project1 #1            // displays "null" if there is no entry in the slot            // displays "notIn" if an entry used to  be there but was removed            // displays the "KEY:" and its "VALUE:" if the entry is there       for(int i = 0; i < hashTable.length; i++) {           if (this.hashTable[i] == null)           {               System.out.println("null");           }           else if (this.hashTable[i].isRemoved())           {               System.out.println("notIn");           }           else           {               System.out.println("KEY: " + this.hashTable[i].key + " VALUE: " + this.hashTable[i].value);           }       }        System.out.println();    } // end display    // Throws an exception if this object is not initialized.    private void checkInitialization()    {        if (!this.initialized)            throw new SecurityException ("HashedDictionary object is not initialized properly.");    } // end checkInitialization    // Ensures that the client requests a capacity    // that is not too small or too large.    private int checkCapacity(int capacity)    {        if (capacity < DEFAULT_CAPACITY)            capacity = DEFAULT_CAPACITY;        else if (capacity > MAX_CAPACITY)            throw new IllegalStateException("Attempt to create a dictionary " +                    "whose capacity is larger than " +                    MAX_CAPACITY);        return capacity;    } // end checkCapacity    // Throws an exception if the hash table becomes too large.    private void checkSize(int size)    {        if (size > MAX_SIZE)            throw new IllegalStateException("Dictionary has become too large.");    } // end checkSize    public int getNumberOfProbes()    {        return this.probes;    }    public V add(K key, V value)    {        checkInitialization();        if ((key == null) || (value == null))            throw new IllegalArgumentException("Cannot add null to a dictionary.");        else        {            V oldValue;                // Value to return            int index = getHashIndex(key);            index = probe(index, key); // Check for and resolve collision            // Assertion: index is within legal range for hashTable            assert (index >= 0) && (index < this.hashTable.length);            if ( (this.hashTable[index] == null) || this.hashTable[index].isRemoved())            {                // Key not found, so insert new entry                this.hashTable[index] = new TableEntry<>(key, value);                this.numberOfEntries++;                oldValue = null;            }            else            {                // Key found; get old value for return and then replace it                oldValue = this.hashTable[index].getValue();                this.hashTable[index].setValue(value);            }            // Ensure that hash table is large enough for another add            if (isHashTableTooFull())                enlargeHashTable();            return oldValue;        }    } // end add    public V remove(K key)    {        checkInitialization();        V removedValue = null;        int index = getHashIndex(key);        index = locate(index, key);        if (index != -1)        {            // Key found; flag entry as removed and return its value            removedValue = this.hashTable[index].getValue();            this.hashTable[index].setToRemoved();            this.numberOfEntries--;        }        // Else not found; result is null        return removedValue;    } // end remove    public V getValue(K key)    {        checkInitialization();        V result = null;        int index = getHashIndex(key);        index = locate(index, key);        if (index != -1)            result = this.hashTable[index].getValue(); // Key found; get value        // Else not found; result is null        return result;    } // end getValue    public boolean contains(K key)    {        return getValue(key) != null;    } // end contains    public boolean isEmpty()    {        return this.numberOfEntries == 0;    } // end isEmpty    public int getSize()    {        return this.numberOfEntries;    } // end getSize    public final void clear()    {        checkInitialization();        for (int index = 0; index < this.hashTable.length; index++)            hashTable[index] = null;        this.numberOfEntries = 0;    } // end clear    public Iterator<K> getKeyIterator()    {        return new KeyIterator();    } // end getKeyIterator    public Iterator<V> getValueIterator()    {        return new ValueIterator();    } // end getValueIterator    private int getHashIndex(K key)    {        int hashIndex = key.hashCode() % this.hashTable.length;        if (hashIndex < 0)        {            hashIndex = hashIndex + this.hashTable.length;        }        return hashIndex;    } // end getHashIndex    private int getHashIndexIncrement(K key)    {        // TODO Project 2 Part 2        int previousPrime =  getPreviousPrime(this.hashTable.length);        final int DEFAULT_PRIME = 7;        int startStep = 0;        int nextStep = previousPrime - key.hashCode() % previousPrime;        while(nextStep < startStep)        {            nextStep += hashTable.length;        }        if(nextStep == startStep)        {            nextStep = DEFAULT_PRIME;        }        //System.out.println("getHashIndexIncrement method - IMPLEMENT ME");        //System.out.println("hash index increment is " + step);        return nextStep;    } // end getHashIndexIncrement    // Precondition: checkInitialization has been called.    private int probe(int index, K key)    {        // TODO Project 2 Part 2        boolean found = false;        int removedStateIndex = -1; // Index of first location in removed state        int step = getHashIndexIncrement(key); // for double hashing ******        while ( !found && (this.hashTable[index] != null) )        {            if (this.hashTable[index].isIn())            {                if (key.equals(this.hashTable[index].getKey()))                    found = true; // Key found                else {                    // Follow probe sequence                    index = (index + step) % this.hashTable.length;         // Linear probing                    this.probes++;                }            }            else // Skip entries that were removed            {                // Save index of first location in removed state                if (removedStateIndex == -1)                    removedStateIndex = index;                index = (index + step) % this.hashTable.length;            // Linear probing                this.probes++;            }        }        // Assertion: Either key or null is found at hashTable[index]        if (found || (removedStateIndex == -1) )            return index;                                      // Index of either key or null        else            return removedStateIndex;                          // Index of an available location    } // end probe    // Precondition: checkInitialization has been called.    private int locate(int index, K key)    {        // TODO Project 2 Part 2        boolean found = false;        int step = getHashIndexIncrement(key); // for double hashing ******        while ( !found && (this.hashTable[index] != null) )        {            if ( this.hashTable[index].isIn() && key.equals(this.hashTable[index].getKey()) )                found = true;                                   // Key found            else            {                // Follow probe sequence                index = (index + step) % this.hashTable.length;         // Linear probing ******                this.probes++;            }        }        // Assertion: Either key or null is found at hashTable[index]        int result = -1;        if (found)            result = index;        return result;    } // end locate    // Increases the size of the hash table to a prime >= twice its old size.    // In doing so, this method must rehash the table entries.    // Precondition: checkInitialization has been called.    private void enlargeHashTable()    {        TableEntry<K, V>[] oldTable = this.hashTable;        int oldSize = this.hashTable.length;        int newSize = getNextPrime(oldSize + oldSize);        checkSize(newSize);        // The cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        TableEntry<K, V>[] tempTable = (TableEntry<K, V>[])new TableEntry[newSize]; // Increase size of array        this.hashTable = tempTable;        this.numberOfEntries = 0; // Reset number of dictionary entries, since        // it will be incremented by add during rehash        // Rehash dictionary entries from old array to the new and bigger array;        // skip both null locations and removed entries        for (int index = 0; index < oldSize; index++)        {            if ( (oldTable[index] != null) && oldTable[index].isIn() )                add(oldTable[index].getKey(), oldTable[index].getValue());        }    } // end enlargeHashTable    // Returns true if lambda > MAX_LOAD_FACTOR for hash table;    // otherwise returns false.    private boolean isHashTableTooFull()    {        return this.numberOfEntries > MAX_LOAD_FACTOR * this.hashTable.length;    } // end isHashTableTooFull    private int getPreviousPrime(int integer)    {        // if even, subtract 1 to make odd        if (integer % 2 == 0)        {            integer--;        }        // test odd integers        while(!isPrime(integer))        {            integer = integer - 2;        }        return integer;    } // end getPreviousPrime    // Returns a prime integer that is >= the given integer.    private int getNextPrime(int integer)    {        // if even, add 1 to make odd        if (integer % 2 == 0)        {            integer++;        }        // test odd integers        while (!isPrime(integer))        {            integer = integer + 2;        }        return integer;    } // end getNextPrime    // Returns true if the given intege is prime.    private boolean isPrime(int integer)    {        boolean result;        boolean done = false;        // 1 and even numbers are not prime        if ( (integer == 1) || (integer % 2 == 0) )        {            result = false;        }        // 2 and 3 are prime        else if ( (integer == 2) || (integer == 3) )        {            result = true;        }        else // integer is odd and >= 5        {            assert (integer % 2 != 0) && (integer >= 5);            // a prime is odd and not divisible by every odd integer up to its square root            result = true; // assume prime            for (int divisor = 3; !done && (divisor * divisor <= integer); divisor = divisor + 2)            {                if (integer % divisor == 0)                {                    result = false; // divisible; not prime                    done = true;                }            }        }        return result;    } // end isPrime    private class KeyIterator implements Iterator<K>    {        private int currentIndex; // Current position in hash table        private int numberLeft;   // Number of entries left in iteration        private KeyIterator()        {            this.currentIndex = 0;            this.numberLeft = numberOfEntries;        } // end default constructor        public boolean hasNext()        {            return this.numberLeft > 0;        } // end hasNext        public K next()        {            K result = null;            if (hasNext())            {                // Skip table locations that do not contain a current entry                while ( (hashTable[this.currentIndex] == null) || hashTable[this.currentIndex].isRemoved() )                {                    this.currentIndex++;                }                result = hashTable[this.currentIndex].getKey();                this.numberLeft--;                this.currentIndex++;            }            else                throw new NoSuchElementException();            return result;        } // end next        public void remove()        {            throw new UnsupportedOperationException();        } // end remove    } // end KeyIterator    private class ValueIterator implements Iterator<V>    {        private int currentIndex;        private int numberLeft;        private ValueIterator()        {            this.currentIndex = 0;            this.numberLeft = numberOfEntries;        } // end default constructor        public boolean hasNext()        {            return this.numberLeft > 0;        } // end hasNext        public V next()        {            V result = null;            if (hasNext())            {                // Skip table locations that do not contain a current entry                while ( (hashTable[this.currentIndex] == null) || hashTable[this.currentIndex].isRemoved() )                {                    this.currentIndex++;                }                result = hashTable[this.currentIndex].getValue();                this.numberLeft--;                this.currentIndex++;            }            else                throw new NoSuchElementException();            return result;        } // end next        public void remove()        {            throw new UnsupportedOperationException();        } // end remove    } // end ValueIterator    private static class TableEntry<S, T> implements Serializable    {        private S key;        private T value;        private States state;                  // Flags whether this entry is in the hash table        private enum States {CURRENT, REMOVED} // Possible values of state        private TableEntry(S searchKey, T dataValue)        {            this.key = searchKey;            this.value = dataValue;            this.state = States.CURRENT;        } // end constructor        private S getKey()        {            return this.key;        } // end getKey        private T getValue()        {            return this.value;        } // end getValue        private void setValue(T newValue)        {            this.value = newValue;        } // end setValue        // Returns true if this entry is currently in the hash table.        private boolean isIn()        {            return this.state == States.CURRENT;        } // end isIn        // Returns true if this entry has been removed from the hash table.        private boolean isRemoved()        {            return this.state == States.REMOVED;        } // end isRemoved        // Sets the state of this entry to removed.        private void setToRemoved()        {            this.key = null;            this.value = null;            this.state = States.REMOVED; // Entry not in use, ie deleted from table        } // end setToRemoved        // Sets the state of this entry to current.        private void setToIn()     // Not used        {            this.state = States.CURRENT; // Entry in use        } // end setToIn    } // end TableEntry}