package Lab09;import java.util.Arrays;import java.util.EmptyStackException;import java.util.Iterator;import java.util.NoSuchElementException;/** * A class of stacks whose entries are stored in an array. * This class provides an iterator. * * @author Frank M. Carrano * @author Timothy M. Henry * @version 3/26/2019 * @modifiedBy Sean Blanchard */public final class ArrayStackWithIterator<T> implements StackInterface<T>, Iterable<T>{    private T[] stack;    // Array of stack entries    private int topIndex; // Index of top entry    private boolean initialized = false;    private static final int DEFAULT_CAPACITY = 50;    private static final int MAX_CAPACITY = 10000;    public ArrayStackWithIterator()    {        this(DEFAULT_CAPACITY);    } // end default constructor    public ArrayStackWithIterator(int initialCapacity)    {        checkCapacity(initialCapacity);        // The cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] tempStack = (T[]) new Object[initialCapacity];        this.stack = tempStack;        this.topIndex = -1;        this.initialized = true;    } // end constructor    public void push(T newEntry)    {        checkInitialization();        ensureCapacity();        this.stack[this.topIndex + 1] = newEntry;        this.topIndex++;    } // end push    public T peek()    {        checkInitialization();        if (isEmpty())            throw new EmptyStackException();        else            return this.stack[this.topIndex];    } // end peek    public T pop()    {        checkInitialization();        if (isEmpty())            throw new EmptyStackException();        else        {            T top = this.stack[this.topIndex];            this.stack[this.topIndex] = null;            this.topIndex--;            return top;        }    } // end pop    public boolean isEmpty()    {        return this.topIndex < 0;    } // end isEmpty    public void clear()    {        checkInitialization();        // Remove references to the objects in the stack,        // but do not deallocate the array        while (this.topIndex > -1)        {            this.stack[this.topIndex] = null;            this.topIndex--;        }    } // end clear    // Throws an exception if this object is not initialized.    private void checkInitialization()    {        if (!this.initialized)            throw new SecurityException(                    "Lab09.ArrayStackWithIterator object is not initialized properly.");    } // end checkInitialization    // Throws an exception if the client requests a capacity that is too large.    private void checkCapacity(int capacity)    {        if (capacity > MAX_CAPACITY)            throw new IllegalStateException("Attempt to create a stack " +                    "whose capacity exceeds " +                    "allowed maximum.");    } // end checkCapacity    // Doubles the size of the array stack if it is full    // Precondition: checkInitialization has been called.    private void ensureCapacity()    {        if (this.topIndex >= this.stack.length - 1) // If array is full, double its size        {            int newLength = 2 * this.stack.length;            checkCapacity(newLength);            this.stack = Arrays.copyOf(this.stack, newLength);        }    } // end ensureCapacity    public Iterator<T> iterator()    {        return new StackIterator();    } // end iterator    private class StackIterator implements Iterator<T>    {        private int nextIndex; // Reference to next index in the array        private StackIterator()        {            this.nextIndex = topIndex;        } // end default constructor        public boolean hasNext()        {            return nextIndex >= 0;        } // end hasNext        public T next()        {            // TODO Project 1                if (hasNext())                {                    //wasNextCalled = true;                    T nextEntry = stack[nextIndex];                    nextIndex--;                    return nextEntry;                }                else                    throw new NoSuchElementException("Illegal call too next(); " +                            "iterator is below the bottom of the stack.");           // TODO done        } // end next        public void remove()        {            // TODO Project 1            throw new UnsupportedOperationException("remove operation is not " +                    "supported by this stack iterator.");            //TODO done        } // end remove    } // end StackIterator    public static void main(String[] args)    {        System.out.println("Creating a stack");        ArrayStackWithIterator<String> myStack = new ArrayStackWithIterator<>();        System.out.println("\nCreating a stackIterator");        Iterator<String> stackIterator = myStack.iterator();        try        {            System.out.println("\nCalling stackIterator.next())");            System.out.println("stackIterator.next() returned = " + stackIterator.next());        } catch (NoSuchElementException nsee)        {            System.out.println("Exception caught \"" + nsee.getMessage() + "\"");        }        System.out.println("\nAdding to stack Jim, Jess, Jill, Jane, Joe");        myStack.push("Jim");        myStack.push("Jess");        myStack.push("Jill");        myStack.push("Jane");        myStack.push("Joe");        System.out.println("\nAccessing the top entry with iterator");        if (stackIterator.hasNext())        {            System.out.println("hasNext() returned true");            System.out.println("stackIterator.next() returned " + stackIterator.next());        } else            System.out.println("hasNext() returned false");        System.out.println("\nResetting the iterator");        stackIterator = myStack.iterator();        System.out.println("The stack contains (from top to bottom):");        while (stackIterator.hasNext())            System.out.println(stackIterator.next());        System.out.println("\nAdding to stack John");        myStack.push("John");        System.out.println("peek() returns: " + myStack.peek());        if (stackIterator.hasNext())        {            System.out.println("hasNext() returned true");            System.out.println("stackIterator.next() returned " + stackIterator.next());        } else            System.out.println("hasNext() returned false");        System.out.println("\nResetting the iterator");        stackIterator = myStack.iterator();        System.out.println("The stack contains (from top to bottom):");        while (stackIterator.hasNext())            System.out.println(stackIterator.next());        try        {            System.out.println("\nCalling stackIterator.remove())");            stackIterator.remove();        } catch (UnsupportedOperationException uoe)        {            System.out.println("Exception caught \"" + uoe.getMessage() + "\"");        }        System.out.println("\n\nDone.");    }  // end main} // end Lab09.ArrayStackWithIterator