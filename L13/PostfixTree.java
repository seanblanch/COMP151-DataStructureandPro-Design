package Lab13;import java.util.Stack;/** * <p/> * A class that creates an expression tree * from a postfix expression of binary operators * and one-letter operands. * * @author Sean Blanchard * @version 4/23/2019 */public class PostfixTree{    private BinaryNode<Character> root;    private final static String OPERATORS = "+-*/";    public PostfixTree()    {        this.root = null;    } // end default constructor    public PostfixTree(String postfix)    {        // TODO Project 2        // This secondary constructor creates the postfix tree        // stack to put partial expressions on        Stack<BinaryNode<Character>> postfixTree = new Stack<>();        // #1 repeat for every character in the postfix        for(int i = 0; i < postfix.length(); i++)            {                char Char = postfix.charAt(i);                //  #2 create subExpression tree of type BinaryNode<Character> with the current character                BinaryNode<Character> node = new BinaryNode<>(Char);                // #3 if the current character is an operator                if (OPERATORS.indexOf(Char) >= 0) {                    // #3a get the operands from the stack                    BinaryNode<Character> left = postfixTree.pop();                    BinaryNode<Character> right = postfixTree.pop();                    // #3b build up the subExpression by setting the left and right                    //     subtrees to the appropriate operands removed from the stack                    //node.setLeftChild(left);                    node.setRightChild(left);                    node.setLeftChild(right);                }                // #4 push subExpression on the stack                postfixTree.push(node);            }            // #5 At the end of it all the entire expression should be the            //    top expression on the stack, so remove it from the stack            //    and point root to it.            //    Note: that the input postfix string and the postorder output            //          should be the same.            root = postfixTree.pop();    } // end constructor    public void inOrderTraversal()    {        inOrder(this.root);        System.out.println();    } // end inOrderTraversal    private void inOrder(BinaryNode<Character> node)    {        if (node != null)        {            inOrder(node.getLeftChild());            System.out.print(node.getData() + " ");            inOrder(node.getRightChild());        } // end if    } // end inOrder    public void postOrderTraversal()    {        // TODO Project 2        //System.out.println("You need to implement me - postOrderTraversal()");        postOrder(this.root);        System.out.println();    } // end postOrderTraversal    private void postOrder(BinaryNode<Character> node)    {        // TODO Project 2        //System.out.println("You need to implement me - postOrder()");        if(node != null)        {            postOrder(node.getLeftChild());            //System.out.print(node.getData() + " ");            postOrder(node.getRightChild());            System.out.print(node.getData() + " ");        }    } // end postOrder    public static void main(String[] args)    {        String expression = "ab*c+";        System.out.println("The first postfix expression is:\n" + expression);        PostfixTree tree = new PostfixTree(expression);        System.out.println("\nThe inorder traversal is:");        tree.inOrderTraversal();        System.out.println("\nThe postorder traversal is:");        tree.postOrderTraversal();        // . . .        expression = "ab-c*def-+g/+";        System.out.println("\nThe second postfix expression is:\n" + expression);        tree = new PostfixTree(expression);        System.out.println("\nThe inorder traversal is:");        tree.inOrderTraversal();        System.out.println("\nThe postorder traversal is:");        tree.postOrderTraversal();    } // end main} // end PostfixTree		